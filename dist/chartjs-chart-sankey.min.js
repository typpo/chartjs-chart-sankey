/*!
 * chartjs-chart-sankey v0.11.0
 * https://github.com/kurkle/chartjs-chart-sankey#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT license
 */
!function(t,o){"object"==typeof exports&&"undefined"!=typeof module?o(require("chart.js-v3"),require("chart.js")):"function"==typeof define&&define.amd?define(["chart.js-v3","chart.js"],o):o((t="undefined"!=typeof globalThis?globalThis:t||self).ChartJsV3$1,t.Chart)}(this,(function(t,o){"use strict";function e(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var r=e(t),n=e(o);const{isArray:i,isNullOrUndef:s}=n.default.helpers;function a(t){return t&&-1!==["min","max"].indexOf(t)?t:"max"}const l=t=>void 0!==t;function c(t,o){const e=t.filter((t=>!o.has(t)));return e.length?e:t.slice(0,1)}const h=(t,o)=>t.x!==o.x?t.x-o.x:t.y-o.y;let f=-1;function d(t,o,e=function(){return f=f<100?f+1:0,f}()){let r=0;for(const n of t)n.node._visited!==e&&(n.node._visited=e,r+=n.node[o].length+d(n.node[o],o,e));return r}const u=t=>(o,e)=>d(o.node[t],t)-d(e.node[t],t)||o.node[t].length-e.node[t].length;function x(t,o){t.from.sort(u("from"));for(const e of t.from){const t=e.node;l(t.y)||(t.y=o,x(t,o)),o=Math.max(t.y+t.out,o)}return o}function y(t,o){t.to.sort(u("to"));for(const e of t.to){const t=e.node;l(t.y)||(t.y=o,y(t,o)),o=Math.max(t.y+t.in,o)}return o}function p(t,o){return l(t.y)?t.y:(t.y=o,o)}function m(t,o){t.sort(((t,o)=>Math.max(o.in,o.out)-Math.max(t.in,t.out)));const e=t[0];e.y=0;const r=x(e,0),n=y(e,0),i=function(t,o){const e=t.filter((t=>0===t.x)),r=t.filter((t=>t.x===o)),n=e.filter((t=>!l(t.y))),i=r.filter((t=>!l(t.y))),s=t.filter((t=>t.x>0&&t.x<o&&!l(t.y)));let a=e.reduce(((t,o)=>Math.max(t,o.y+o.out||0)),0),c=r.reduce(((t,o)=>Math.max(t,o.y+o.in||0)),0),h=0;return a>=c?(n.forEach((t=>{a=p(t,a),a=Math.max(a+t.out,y(t,a))})),i.forEach((t=>{c=p(t,c),c=Math.max(c+t.in,y(t,c))}))):(i.forEach((t=>{c=p(t,c),c=Math.max(c+t.in,y(t,c))})),n.forEach((t=>{a=p(t,a),a=Math.max(a+t.out,y(t,a))}))),s.forEach((o=>{let e=t.filter((t=>t.x===o.x&&l(t.y))).reduce(((t,o)=>Math.max(t,o.y+Math.max(o.in,o.out))),0);e=p(o,e),e=Math.max(e+o.in,x(o,e)),e=Math.max(e+o.out,y(o,e)),h=Math.max(h,e)})),Math.max(a,c,h)}(t,o);return Math.max(r,n,i)}function g(t,o,e,r){const n=[...t.values()],i=function(t,o){const e=new Set(o.map((t=>t.to))),r=new Set(o.map((t=>t.from))),n=new Set([...t.keys()]);let i=0;for(;n.size;){const r=c([...n],e);for(const o of r){const e=t.get(o);l(e.x)||(e.x=i),n.delete(o)}n.size&&(e.clear(),o.filter((t=>n.has(t.from))).forEach((t=>e.add(t.to))),i++)}return[...t.keys()].filter((t=>!r.has(t))).forEach((o=>{const e=t.get(o);e.column||(e.x=i)})),i}(t,o),s=e?function(t,o){let e=0,r=0;for(let n=0;n<=o;n++){let o=r;const i=t.filter((t=>t.x===n)).sort(((t,o)=>t.priority-o.priority));r=i[0].to.filter((t=>t.node.x>n+1)).reduce(((t,o)=>t+o.flow),0)||0;for(const t of i)t.y=o,o+=Math.max(t.out,t.in);e=Math.max(o,e)}return e}(n,i):m(n,i),a=function(t,o){let e=1,r=0,n=0,i=0;const s=[];t.sort(h);for(const a of t){if(a.y){if(0===a.x)s.push(a.y);else{for(r!==a.x&&(r=a.x,n=0),e=n+1;e<s.length&&!(s[e]>a.y);e++);n=e}a.y+=e*o,e++}i=Math.max(i,a.y+Math.max(a.in,a.out))}return i}(n,.03*s);return function(t,o){t.forEach((t=>{const e=Math[o](t.in||t.out,t.out||t.in),r=e<t.in,n=e<t.out;let i=0,s=t.from.length;t.from.sort(((t,o)=>t.node.y+t.node.out/2-(o.node.y+o.node.out/2))).forEach(((t,o)=>{r?t.addY=o*(e-t.flow)/(s-1):(t.addY=i,i+=t.flow)})),i=0,s=t.to.length,t.to.sort(((t,o)=>t.node.y+t.node.in/2-(o.node.y+o.node.in/2))).forEach(((t,o)=>{n?t.addY=o*(e-t.flow)/(s-1):(t.addY=i,i+=t.flow)}))}))}(n,r),{maxX:i,maxY:a}}const{DatasetController:M}=r.default,{valueOrDefault:w,toFont:b,isNullOrUndef:v}=r.default.helpers;function _(t,o,e){for(const r of t)if(r.key===o&&r.index===e)return r.addY;return 0}class k extends M{parseObjectData(t,o,e,r){const{from:n="from",to:i="to",flow:s="flow"}=this.options.parsing,l=o.map((({[n]:t,[i]:o,[s]:e})=>({from:t,to:o,flow:e}))),{xScale:c,yScale:h}=t,f=[],d=this._nodes=function(t){const o=new Map;for(let e=0;e<t.length;e++){const{from:r,to:n,flow:i}=t[e];if(o.has(r)){const t=o.get(r);t.out+=i,t.to.push({key:n,flow:i,index:e})}else o.set(r,{key:r,in:0,out:i,from:[],to:[{key:n,flow:i,index:e}]});if(o.has(n)){const t=o.get(n);t.in+=i,t.from.push({key:r,flow:i,index:e})}else o.set(n,{key:n,in:i,out:0,from:[{key:r,flow:i,index:e}],to:[]})}const e=(t,o)=>o.flow-t.flow;return[...o.values()].forEach((t=>{t.from=t.from.sort(e),t.from.forEach((t=>{t.node=o.get(t.key)})),t.to=t.to.sort(e),t.to.forEach((t=>{t.node=o.get(t.key)}))})),o}(l),{column:u,priority:x,size:y}=this.getDataset();if(x)for(const t of d.values())t.key in x&&(t.priority=x[t.key]);if(u)for(const t of d.values())t.key in u&&(t.column=!0,t.x=u[t.key]);const{maxX:p,maxY:m}=g(d,l,!!x,a(y));this._maxX=p,this._maxY=m;for(let t=0,o=l.length;t<o;++t){const o=l[t],e=d.get(o.from),r=d.get(o.to),n=e.y+_(e.to,o.to,t),i=r.y+_(r.from,o.from,t);f.push({x:c.parse(e.x,t),y:h.parse(n,t),_custom:{from:e,to:r,x:c.parse(r.x,t),y:h.parse(i,t),height:h.parse(o.flow,t)}})}return f.slice(e,e+r)}getMinMax(t){return{min:0,max:t===this._cachedMeta.xScale?this._maxX:this._maxY}}update(t){const{data:o}=this._cachedMeta;this.updateElements(o,0,o.length,t)}updateElements(t,o,e,r){const{xScale:n,yScale:i}=this._cachedMeta,s=this.resolveDataElementOptions(o,r),a=this.getSharedOptions(r,t[o],s),l=this.getDataset(),c=w(l.borderWidth,1)/2+.5,h=w(l.nodeWidth,10);for(let s=o;s<o+e;s++){const o=this.getParsed(s),e=o._custom,a=i.getPixelForValue(o.y);this.updateElement(t[s],s,{x:n.getPixelForValue(o.x)+h+c,y:a,x2:n.getPixelForValue(e.x)-c,y2:i.getPixelForValue(e.y),from:e.from,to:e.to,progress:"reset"===r?0:1,height:Math.abs(i.getPixelForValue(o.y+e.height)-a),options:this.resolveDataElementOptions(s,r)},r)}this.updateSharedOptions(a,r)}_drawLabels(){const t=this._ctx,o=this._nodes||new Map,e=this.getDataset(),r=a(e.size),n=w(e.borderWidth,1),i=w(e.nodeWidth,10),s=e.labels,{xScale:l,yScale:c}=this._cachedMeta;t.save();const h=this.chart.chartArea;for(const a of o.values()){const o=l.getPixelForValue(a.x),f=c.getPixelForValue(a.y),d=Math[r](a.in||a.out,a.out||a.in),u=Math.abs(c.getPixelForValue(a.y+d)-f),x=s&&s[a.key]||a.key;let y=o;t.fillStyle=e.color||"black",t.textBaseline="middle",o<h.width/2?(t.textAlign="left",y+=i+n+4):(t.textAlign="right",y-=n+4),this._drawLabel(x,f,u,t,y)}t.restore()}_drawLabel(t,o,e,r,n){const a=b(this.options.font,this.chart.options.font),l=v(t)?[]:function(t){const o=[],e=i(t)?t:s(t)?[]:[t];for(;e.length;){const t=e.pop();"string"==typeof t?o.unshift.apply(o,t.split("\n")):Array.isArray(t)?e.push.apply(e,t):s(e)||o.unshift(""+t)}return o}(t),c=l.length,h=o+e/2,f=a.lineHeight,d=w(this.options.padding,f/2);if(r.font=a.string,c>1){const t=h-f*c/2+d;for(let o=0;o<c;o++)r.fillText(l[o],n,t+o*f)}else r.fillText(t,n,h)}_drawNodes(){const t=this._ctx,o=this._nodes||new Map,e=this.getDataset(),r=a(e.size),{xScale:n,yScale:i}=this._cachedMeta,s=w(e.borderWidth,1),l=w(e.nodeWidth,10);t.save(),t.strokeStyle=e.borderColor||"black",t.lineWidth=s;for(const e of o.values()){t.fillStyle=e.color;const o=n.getPixelForValue(e.x),a=i.getPixelForValue(e.y),c=Math[r](e.in||e.out,e.out||e.in),h=Math.abs(i.getPixelForValue(e.y+c)-a);s&&t.strokeRect(o,a,l,h),t.fillRect(o,a,l,h)}t.restore()}draw(){const t=this._ctx,o=this.getMeta().data||[],e=[];for(let t=0,r=o.length;t<r;++t){const r=o[t];r.from.color=r.options.colorFrom,r.to.color=r.options.colorTo,r.active&&e.push(r)}for(const t of e)t.from.color=t.options.colorFrom,t.to.color=t.options.colorTo;this._drawNodes();for(let e=0,r=o.length;e<r;++e)o[e].draw(t);this._drawLabels()}}k.id="sankey",k.defaults={dataElementType:"flow",animations:{numbers:{type:"number",properties:["x","y","x2","y2","height"]},progress:{easing:"linear",duration:t=>"data"===t.type?200*(t.parsed._custom.x-t.parsed.x):void 0,delay:t=>"data"===t.type?500*t.parsed.x+20*t.dataIndex:void 0},colors:{type:"color",properties:["colorFrom","colorTo"]}},transitions:{hide:{animations:{colors:{type:"color",properties:["colorFrom","colorTo"],to:"transparent"}}},show:{animations:{colors:{type:"color",properties:["colorFrom","colorTo"],from:"transparent"}}}}},k.overrides={interaction:{mode:"nearest",intersect:!0},datasets:{clip:!1,parsing:!0},plugins:{tooltip:{callbacks:{title:()=>"",label(t){const o=t.dataset.data[t.dataIndex];return o.from+" -> "+o.to+": "+o.flow}}},legend:{display:!1}},scales:{x:{type:"linear",bounds:"data",display:!1,min:0,offset:!1},y:{type:"linear",bounds:"data",display:!1,min:0,reverse:!0,offset:!1}},layout:{padding:{top:3,left:3,right:13,bottom:3}}};const{Element:S}=r.default,{color:F,getHoverColor:P}=r.default.helpers,E=(t,o,e,r)=>t<e?{cp1:{x:t+(e-t)/3*2,y:o},cp2:{x:t+(e-t)/3,y:r}}:{cp1:{x:t-(t-e)/3,y:0},cp2:{x:e+(t-e)/3,y:0}},T=(t,o,e)=>({x:t.x+e*(o.x-t.x),y:t.y+e*(o.y-t.y)});class C extends S{constructor(t){super(),this.options=void 0,this.x=void 0,this.y=void 0,this.x2=void 0,this.y2=void 0,this.height=void 0,t&&Object.assign(this,t)}draw(t){const{x:o,x2:e,y:r,y2:n,height:i,progress:s}=this,{cp1:a,cp2:l}=E(o,r,e,n);0!==s&&(t.save(),s<1&&(t.beginPath(),t.rect(o,Math.min(r,n),(e-o)*s+1,Math.abs(n-r)+i+1),t.clip()),function(t,{x:o,x2:e,options:r}){let n;"from"===r.colorMode?n=F(r.colorFrom).alpha(.5).rgbString():"to"===r.colorMode?n=F(r.colorTo).alpha(.5).rgbString():(n=t.createLinearGradient(o,0,e,0),n.addColorStop(0,F(r.colorFrom).alpha(.5).rgbString()),n.addColorStop(1,F(r.colorTo).alpha(.5).rgbString())),t.fillStyle=n,t.strokeStyle=n,t.lineWidth=.5}(t,this),t.beginPath(),t.moveTo(o,r),t.bezierCurveTo(a.x,a.y,l.x,l.y,e,n),t.lineTo(e,n+i),t.bezierCurveTo(l.x,l.y+i,a.x,a.y+i,o,r+i),t.lineTo(o,r),t.stroke(),t.closePath(),t.fill(),t.restore())}inRange(t,o,e){const{x:r,y:n,x2:i,y2:s,height:a}=this.getProps(["x","y","x2","y2","height"],e);if(t<r||t>i)return!1;const{cp1:l,cp2:c}=E(r,n,i,s),h=(t-r)/(i-r),f={x:i,y:s},d=T({x:r,y:n},l,h),u=T(l,c,h),x=T(c,f,h),y=T(d,u,h),p=T(u,x,h),m=T(y,p,h).y;return o>=m&&o<=m+a}inXRange(t,o){const{x:e,x2:r}=this.getProps(["x","x2"],o);return t>=e&&t<=r}inYRange(t,o){const{y:e,y2:r,height:n}=this.getProps(["y","y2","height"],o),i=Math.min(e,r),s=Math.max(e,r)+n;return t>=i&&t<=s}getCenterPoint(t){const{x:o,y:e,x2:r,y2:n,height:i}=this.getProps(["x","y","x2","y2","height"],t);return{x:(o+r)/2,y:(e+n+i)/2}}tooltipPosition(t){return this.getCenterPoint(t)}getRange(t){return"x"===t?this.width/2:this.height/2}}C.id="flow",C.defaults={colorFrom:"red",colorTo:"green",colorMode:"gradient",hoverColorFrom:(t,o)=>P(o.colorFrom),hoverColorTo:(t,o)=>P(o.colorTo)},t.Chart.register(k,C)}));
